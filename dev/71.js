(this.webpackJsonp=this.webpackJsonp||[]).push([[71],{56:function(a,n,e){"use strict";e.r(n),n.default=";; implementation of a dfs in steel\n\n;; Given a node and a graph\n;; node -> 'a\n;; graph -> '((a b c) (b d) (e f))\n;;\n;; returns the neighbors\n;; ex.\n;; (get-neighbors 'a graph) => '(b c)\n;;\n(define (get-neighbors node graph)\n  (define found-neighbors (assoc node graph))\n  (if found-neighbors\n      (cdr found-neighbors)\n      '()))\n\n(define (longest  lst)\n  (foldr (Î» (a b) (if (> (length a) (length b)) a b))\n         '()\n         lst))\n\n(define (reverse ls)\n  (define (my-reverse-2 ls acc)\n    (if (null? ls)\n      acc\n      (my-reverse-2 (cdr ls) (cons (car ls) acc))))\n  (my-reverse-2 ls '()))\n\n(define (first-step curr end graph)\n  (define neighbors (get-neighbors curr graph))\n  (longest (map (lambda (x) (dfs x end '() '() graph)) neighbors)))\n\n\n(define (member? x los)\n  (cond\n    ((null? los) #f)\n    ((equal? x (car los)) #t)\n    (else (member? x (cdr los)))))\n\n;; iteratively tries each neighbor\n;; quits when the length is worse\n(define (try-all-neighbors neighbors best-path end new-path graph)\n  (if (not (empty? neighbors))\n      (let* ((next-neighbor (car neighbors))\n             (found-path (dfs next-neighbor end new-path best-path graph)))\n        (if (> (length found-path) (length best-path))\n            (try-all-neighbors (cdr neighbors) found-path end new-path graph)\n            (try-all-neighbors (cdr neighbors) best-path end new-path graph)))\n      best-path))\n\n(define (dfs curr end path best-path graph)\n  (define neighbors (get-neighbors curr graph))\n  (define new-path (cons curr path))\n  (cond ((equal? curr end)\n         (cons curr path))\n        ((member? curr path)\n         '())\n        (neighbors\n         (try-all-neighbors neighbors best-path end (cons curr path) graph))\n        (else '())))\n\n(define (longest-path start end graph)\n  (define found-path (reverse (first-step start end graph)))\n  (cond ((empty? found-path)\n         (if (equal? start end)\n             (list start)\n             '()))\n        ((and (equal? (car found-path) start) (not (equal? start end)))\n         found-path)\n        (else (cons start found-path))))\n\n\n(longest-path 'a 'c '((a b) (b c))) ;; '(a b c)\n(longest-path 'a 'c '((a b) (b a c))) ;; '(a b c)\n(longest-path 'a 'c '((a d e f g b) (b a c))) ;; '(a b c)\n(longest-path 'a 'a '((a b) (b a c))) ;; '(a b a)\n(longest-path 'a 'c '((a b) (b a) (c))) ;; '()\n(longest-path 'a 'f '((a b c) (b f) (c d) (d e) (e f))) ;; '(a c d e f)\n(longest-path 'a 'f '((a b c a) (b c d) (c e a) (d e f) (e d f))) ;; '(a b c e d f)\n(longest-path 'a 'a '((a b c a) (b c d) (c e a) (d e f) (e d f))) ;; '(a b c a)\n(longest-path 'a 'a '((a b) (b c))) ;; '(a)\n(longest-path 'a 'a '((a a b) (b c))) ;; '(a a)\n(longest-path 'a 'a '((a b a) (b c))) ;; '(a a)\n(longest-path 'a 'b '((a b) (b c) (c b))) ;; '(a b)\n(longest-path 'a 'b '((a b c) (b c) (c b))) ;; '(a c b)\n\n(equal? (longest-path 'a 'c '((a b) (b c))) '(a b c))\n(equal? (longest-path 'a 'c '((a b) (b a c))) '(a b c))\n(equal? (longest-path 'a 'c '((a d e f g b) (b a c))) '(a b c))\n(equal? (longest-path 'a 'a '((a b) (b a c))) '(a b a))\n(equal? (longest-path 'a 'c '((a b) (b a) (c))) '())\n(equal? (longest-path 'a 'f '((a b c) (b f) (c d) (d e) (e f))) '(a c d e f))\n(equal? (longest-path 'a 'f '((a b c a) (b c d) (c e a) (d e f) (e d f))) '(a b c e d f))\n(equal? (longest-path 'a 'a '((a b c a) (b c d) (c e a) (d e f) (e d f))) '(a b c a))\n(equal? (longest-path 'a 'a '((a b) (b c))) '(a))\n(equal? (longest-path 'a 'a '((a a b) (b c))) '(a a))\n(equal? (longest-path 'a 'a '((a b a) (b c))) '(a a))\n(equal? (longest-path 'a 'b '((a b) (b c) (c b))) '(a b))\n(equal? (longest-path 'a 'b '((a b c) (b c) (c b))) '(a c b))\n"}}]);