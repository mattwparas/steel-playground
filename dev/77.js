(this.webpackJsonp=this.webpackJsonp||[]).push([[77],{62:function(n,e,t){"use strict";t.r(e),e.default=";; Implementation of a stack in `steel`\n;; Returning multiple values requires returning as a list\n;; Functional data structure, is definitely verbose but is super helpful\n;; Maybe look into using monadic forms in order to not have the verbosity\n;; associated with a functional data structure\n\n\n;; ---------------------------------------------------------------------\n;; Implementation of a stack purely using a list\n;; ---------------------------------------------------------------------\n\n\n;; destruct works like so:\n;; (destruct (a b c) value)\n;;  ...\n;; (define a (car value))\n;; (define b (car (cdr value)))\n;; (define c (car (cdr (cdr value))))\n(define-syntax destruct\n  (syntax-rules ()\n    [(destruct (var) ret-value)\n     (define (datum->syntax var) (car ret-value))]\n    [(destruct (var1 var2 ...) ret-value)\n     (begin (define (datum->syntax var1) (car ret-value))\n            (destruct (var2 ...) (cdr ret-value)))]))\n\n\n(define (any? v) #t)\n(define stack? list?)\n(define (pair? s)\n  (and (list? s) (= (length s) 2)))\n\n\n(define (make-stack) '())\n\n(define/contract (pop stack)\n  (->/c stack? pair?)\n  (if (null? stack)\n      '(#f '())\n      (list (car stack) (cdr stack))))\n\n;; value -> stack -> stack\n(define push cons)\n\n;; instantiate an empty stack\n(define my-stack (make-stack))\n\n;; Bind the last few values from the stack\n;; Push the values 1, 2, 3, 4, then pop and return the value and the stack\n(destruct (pop-val new-stack)\n          (->> my-stack\n               (push 1)\n               (push 2)\n               (push 3)\n               (push 4)\n               (pop)))\n\npop-val ;; => 4\nnew-stack ;; => '(3 2 1)\n"}}]);