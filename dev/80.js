(this.webpackJsonp=this.webpackJsonp||[]).push([[80],{65:function(e,t,r){"use strict";r.r(t),t.default=';; ------------------------- TRIE ---------------------------- ;;\n\n(struct trie (char children end-word? word-up-to))\n\n;; Rename functions for the sake of compatibility\n(define empty (list))\n(define empty-trie (trie void empty #f empty))\n\n;; Throw in a mediocre flatten definition\n(define (flatten lst)\n  (cond ((null? lst) empty)\n        ((list? lst)\n         (append (flatten (car lst)) (flatten (cdr lst))))\n        (else (list lst))))\n\n;; contract: (listof char?) (listof tries?) integer? -> (listof trie?)\n(define (create-children char-list lst prefix-chars)\n  (cond [(= (length char-list) 1)\n         (handle-last-letter char-list lst prefix-chars)]\n        [else ;; you are in the middle of the word\n         (handle-intern-letter char-list lst prefix-chars)]))\n\n;; contract: (listof char?) (listof trie?) integer? -> (listof trie?)\n(define (handle-last-letter char-list lst prefix-chars)\n  (define char (first char-list))\n  ; (define next-prefix (append prefix-chars (list char)))\n  (define next-prefix (push-back prefix-chars char))\n  (cond [(empty? lst) ;; children are empty, return list of empty children\n         (list (trie char empty #t next-prefix))]\n        [(< char (trie-char (first lst))) ;; less than, put it to the left\n         (cons (trie char empty #t next-prefix) lst)]\n        [(= char (trie-char (first lst))) ;; equal, step down a level\n         (cons (trie char (trie-children (first lst)) #t next-prefix) (rest lst))]\n        [else ;; move to the right\n         (cons (first lst)\n               (create-children char-list (rest lst) prefix-chars))]))\n\n;; contract: (listof char?) (listof trie?) integer? -> (listof trie?)\n(define (handle-intern-letter char-list lst prefix-chars)\n  (define char (first char-list))\n  ; (define next-prefix (append prefix-chars (list char)))\n  (define next-prefix (push-back prefix-chars char))\n  (cond [(empty? lst) ;; no children, pop off front and step down\n         (list (trie char (create-children\n                           (rest char-list) empty next-prefix) #f next-prefix))]\n        [(< char (trie-char (first lst))) ;; place where it is, pop off front and go\n         (cons (trie char (create-children\n                           (rest char-list) empty next-prefix) #f next-prefix) lst)]\n        [(= char (trie-char (first lst))) ;; equal, step down\n         (cons (trie char (create-children (rest char-list) (trie-children (first lst)) next-prefix)\n                     (trie-end-word? (first lst))\n                     (trie-word-up-to (first lst)))\n               (rest lst))]\n        [else ; move to the right\n         (cons (first lst)\n               (create-children char-list (rest lst) prefix-chars))]))\n\n;; contract: trie? string? integer? -> trie?\n(define (insert root-trie word)\n  (define char-list (string->list word))\n  (trie\n   (trie-char root-trie)\n   (create-children char-list (trie-children root-trie) empty)\n   (trie-end-word? root-trie)\n   (trie-word-up-to root-trie)))\n\n; contract: trie? trie? -> boolean?\n(define (trie<? trie-node1 trie-node2)\n  (< (trie-char trie-node1) (trie-char trie-node2)))\n\n;; contract: trie? -> void\n(define (pre-order-traverse trie-node)\n  (displayln (list (trie-char trie-node) (trie-end-word? trie-node) (trie-word-up-to trie-node)))\n  (map pre-order-traverse (trie-children trie-node))\n  "finished")\n\n;; contract: trie? (listof string?) -> trie?\n(define (build-trie-from-list-of-words trie list-of-words)\n  (cond\n    [(= (length list-of-words) 1)\n     (insert trie (first list-of-words))]\n    [else\n     (build-trie-from-list-of-words\n      (insert trie (first list-of-words))\n      (rest list-of-words))]))\n\n;; ------------------ SORTING ---------------------- ;;\n\n(define (trie-sort list-of-words)\n  (pre-order (build-trie-from-list-of-words empty-trie list-of-words)))\n\n;; contract: trie? -> (listof string?)\n(define (pre-order trie-node)\n  (if (trie-end-word? trie-node)\n    (cons (list->string (trie-word-up-to trie-node))\n      (flatten (map pre-order (trie-children trie-node))))\n    (flatten (map pre-order (trie-children trie-node)))))\n\n\n(define test-list\n  (list\n   "suppose"\n   "believe"\n   "changeable"\n   "absent"\n   "busy"\n   "float"\n   "debonair"\n   "throat"\n   "grey"\n   "use"\n   "measure"\n   "van"\n   "thirsty"\n   "notify"\n   "star"\n))\n\n(define (generate-trie list-of-words)\n  (build-trie-from-list-of-words empty-trie list-of-words))\n\n(pre-order (generate-trie test-list))\n'}}]);